## ðŸ“¦ BACKUP & RESTORE MODULE

ðŸ“„ Creating `modules/mod.backup/folder.backup.ps1`:

```powershell
<#
.SYNOPSIS
    Knoux Spectre Folder Backup Utility
.DESCRIPTION
    Backup and restore folders with compression and scheduling
.AUTHOR
    Knoux Systems
.VERSION
    1.0.0
#>

function Show-BackupUtility {
    [CmdletBinding()]
    param()
    
    Clear-ScreenWithBackground
    Write-Host "${ANSI.BG_DARK}${ANSI.PURPLE}${ANSI.BOLD}ðŸ“¦ FOLDER BACKUP UTILITY${ANSI.RESET}"
    Write-Host "${ANSI.BORDER}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${ANSI.RESET}"
    Write-Host ""
    
    do {
        Write-Host "${ANSI.TEXT_SECONDARY}Backup Options:${ANSI.RESET}"
        Write-Host " ${ANSI.PURPLE}1${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Create Folder Backup${ANSI.RESET}"
        Write-Host " ${ANSI.PURPLE}2${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Restore Folder Backup${ANSI.RESET}"
        Write-Host " ${ANSI.PURPLE}3${ANSI.RESET} ${ANSI.TEXT_PRIMARY}List Existing Backups${ANSI.RESET}"
        Write-Host " ${ANSI.PURPLE}4${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Schedule Automatic Backup${ANSI.RESET}"
        Write-Host " ${ANSI.PURPLE}5${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Backup System State${ANSI.RESET}"
        Write-Host ""
        Write-Host " ${ANSI.RED}0${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Back to Menu${ANSI.RESET}"
        Write-Host ""
        
        $choice = Read-ValidatedSubInput -Max 5
        
        switch ($choice) {
            0 { return }
            1 { Create-FolderBackup }
            2 { Restore-FolderBackup }
            3 { List-Backups }
            4 { Schedule-Backup }
            5 { Backup-SystemState }
        }
        
        Write-Host ""
        Write-Host "${ANSI.TEXT_SECONDARY}Press any key to continue...${ANSI.RESET}"
        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
        Clear-ScreenWithBackground
        
    } while ($true)
}

function Create-FolderBackup {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter source folder path to backup:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $sourcePath = Read-Host
    
    if ([string]::IsNullOrWhiteSpace($sourcePath)) {
        Write-Host "${ANSI.RED}Ã— Source path cannot be empty${ANSI.RESET}"
        return
    }
    
    if (-not (Test-Path $sourcePath)) {
        Write-Host "${ANSI.RED}Ã— Source folder not found: $sourcePath${ANSI.RESET}"
        return
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter backup destination folder:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $destPath = Read-Host
    
    if ([string]::IsNullOrWhiteSpace($destPath)) {
        Write-Host "${ANSI.RED}Ã— Destination path cannot be empty${ANSI.RESET}"
        return
    }
    
    # Create destination if it doesn't exist
    if (-not (Test-Path $destPath)) {
        try {
            New-Item -ItemType Directory -Path $destPath -Force | Out-Null
            Write-Host "${ANSI.GREEN}âœ“ Created backup directory: $destPath${ANSI.RESET}"
        } catch {
            Write-Host "${ANSI.RED}Ã— Failed to create backup directory: $($_.Exception.Message)${ANSI.RESET}"
            return
        }
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter backup name (optional):${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $backupName = Read-Host
    
    if ([string]::IsNullOrWhiteSpace($backupName)) {
        $backupName = Split-Path $sourcePath -Leaf
    }
    
    # Sanitize backup name
    $backupName = $backupName -replace '[^a-zA-Z0-9\-_]', '_'
    
    # Add timestamp
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $backupFileName = "${backupName}_$timestamp.zip"
    $backupFilePath = Join-Path $destPath $backupFileName
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Compressing folder...${ANSI.RESET}"
    
    try {
        # Get source folder size
        $sourceSize = (Get-ChildItem -Path $sourcePath -Recurse -Force -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum).Sum
        
        Write-Host "${ANSI.TEXT_SECONDARY}Source size: $(Format-KnouxBytes $sourceSize)${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Backup file: $backupFilePath${ANSI.RESET}"
        
        # Create zip archive
        Add-Type -AssemblySystem.IO.Compression.FileSystem
        $compressionLevel = [System.IO.Compression.CompressionLevel]::Optimal
        
        Show-KnouxProgress "Compressing files" 0
        [System.IO.Compression.ZipFile]::CreateFromDirectory($sourcePath, $backupFilePath, $compressionLevel, $false)
        
        # Get backup file size
        $backupSize = (Get-Item $backupFilePath).Length
        $compressionRatio = [math]::Round((($sourceSize - $backupSize) / $sourceSize) * 100, 2)
        
        Write-Host ""
        Write-Host "${ANSI.GREEN}âœ“ Backup created successfully${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Backup size: $(Format-KnouxBytes $backupSize)${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Compression ratio: $compressionRatio%${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Backup file: $backupFilePath${ANSI.RESET}"
        
        # Record backup metadata
        $metadata = @{
            SourcePath = $sourcePath
            BackupPath = $backupFilePath
            Timestamp = Get-Date
            SourceSize = $sourceSize
            BackupSize = $backupSize
            CompressionRatio = $compressionRatio
        }
        
        $metadataPath = "$backupFilePath.metadata.json"
        $metadata | ConvertTo-Json | Out-File -FilePath $metadataPath -Encoding UTF8
        
        Write-Host "${ANSI.GREEN}âœ“ Metadata saved to: $metadataPath${ANSI.RESET}"
    } catch {
        Write-Host "${ANSI.RED}Ã— Error creating backup: $($_.Exception.Message)${ANSI.RESET}"
    }
}

function Restore-FolderBackup {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter path to backup file (.zip):${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $backupPath = Read-Host
    
    if ([string]::IsNullOrWhiteSpace($backupPath)) {
        Write-Host "${ANSI.RED}Ã— Backup path cannot be empty${ANSI.RESET}"
        return
    }
    
    if (-not (Test-Path $backupPath)) {
        Write-Host "${ANSI.RED}Ã— Backup file not found: $backupPath${ANSI.RESET}"
        return
    }
    
    if (-not $backupPath.EndsWith(".zip")) {
        Write-Host "${ANSI.RED}Ã— File must be a .zip archive${ANSI.RESET}"
        return
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter restore destination folder:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $restorePath = Read-Host
    
    if ([string]::IsNullOrWhiteSpace($restorePath)) {
        Write-Host "${ANSI.RED}Ã— Restore path cannot be empty${ANSI.RESET}"
        return
    }
    
    # Check for existing folder
    if (Test-Path $restorePath) {
        $confirm = Confirm-KnouxAction "Destination folder exists. Overwrite?" "N"
        if (-not $confirm) {
            Write-Host "${ANSI.TEXT_SECONDARY}Cancelled restore operation${ANSI.RESET}"
            return
        }
    } else {
        # Create destination folder
        try {
            New-Item -ItemType Directory -Path $restorePath -Force | Out-Null
        } catch {
            Write-Host "${ANSI.RED}Ã— Failed to create restore directory: $($_.Exception.Message)${ANSI.RESET}"
            return
        }
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Restoring backup...${ANSI.RESET}"
    
    try {
        # Extract zip archive
        Add-Type -AssemblySystem.IO.Compression.FileSystem
        
        Show-KnouxProgress "Extracting files" 0
        [System.IO.Compression.ZipFile]::ExtractToDirectory($backupPath, $restorePath)
        
        Write-Host ""
        Write-Host "${ANSI.GREEN}âœ“ Backup restored successfully${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Files restored to: $restorePath${ANSI.RESET}"
        
        # Check for metadata
        $metadataPath = "$backupPath.metadata.json"
        if (Test-Path $metadataPath) {
            Write-Host ""
            Write-Host "${ANSI.TEXT_SECONDARY}Backup metadata found:${ANSI.RESET}"
            $metadata = Get-Content $metadataPath | ConvertFrom-Json
            Write-Host " ${ANSI.TEXT_SECONDARY}Original source:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$($metadata.SourcePath)${ANSI.RESET}"
            Write-Host " ${ANSI.TEXT_SECONDARY}Backup date:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$($metadata.Timestamp)${ANSI.RESET}"
            Write-Host " ${ANSI.TEXT_SECONDARY}Compression ratio:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$($metadata.CompressionRatio)%${ANSI.RESET}"
        }
    } catch {
        Write-Host "${ANSI.RED}Ã— Error restoring backup: $($_.Exception.Message)${ANSI.RESET}"
    }
}

function List-Backups {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter backup directory path:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $backupDir = Read-Host
    
    if ([string]::IsNullOrWhiteSpace($backupDir)) {
        Write-Host "${ANSI.RED}Ã— Backup directory path cannot be empty${ANSI.RESET}"
        return
    }
    
    if (-not (Test-Path $backupDir)) {
        Write-Host "${ANSI.RED}Ã— Backup directory not found: $backupDir${ANSI.RESET}"
        return
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Searching for backups...${ANSI.RESET}"
    
    try {
        $backups = Get-ChildItem -Path $backupDir -Filter "*.zip" | Sort-Object LastWriteTime -Descending
        
        if ($backups.Count -eq 0) {
            Write-Host "${ANSI.TEXT_SECONDARY}No backups found in $backupDir${ANSI.RESET}"
            return
        }
        
        Write-Host ""
        Write-Host "${ANSI.PURPLE}${ANSI.BOLD}AVAILABLE BACKUPS ($($backups.Count))${ANSI.RESET}"
        Write-Host "${ANSI.BORDER}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${ANSI.RESET}"
        
        for ($i = 0; $i -lt $backups.Count; $i++) {
            $backup = $backups[$i]
            $size = Format-KnouxBytes $backup.Length
            $date = $backup.LastWriteTime.ToString("yyyy-MM-dd HH:mm")
            $name = $backup.Name
            
            Write-Host " ${ANSI.PURPLE}$($i + 1)${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$name${ANSI.RESET}"
            Write-Host "   ${ANSI.TEXT_SECONDARY}Size:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$size${ANSI.RESET} ${ANSI.TEXT_SECONDARY}Date:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$date${ANSI.RESET}"
            
            # Check for metadata
            $metadataPath = "$($backup.FullName).metadata.json"
            if (Test-Path $metadataPath) {
                try {
                    $metadata = Get-Content $metadataPath | ConvertFrom-Json
                    $originalSize = Format-KnouxBytes $metadata.SourceSize
                    Write-Host "   ${ANSI.TEXT_SECONDARY}Original:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$originalSize${ANSI.RESET} ${ANSI.TEXT_SECONDARY}Compression:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$($metadata.CompressionRatio)%${ANSI.RESET}"
                } catch {
                    # Ignore metadata errors
                }
            }
            
            Write-Host ""
        }
    } catch {
        Write-Host "${ANSI.RED}Ã— Error listing backups: $($_.Exception.Message)${ANSI.RESET}"
    }
}

function Schedule-Backup {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Scheduled backups require Task Scheduler${ANSI.RESET}"
    Write-Host "${ANSI.TEXT_SECONDARY}This feature creates automated backup tasks${ANSI.RESET}"
    Write-Host ""
    
    Write-Host "${ANSI.TEXT_SECONDARY}Enter source folder to backup:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $sourcePath = Read-Host
    
    if ([string]::IsNullOrWhiteSpace($sourcePath)) {
        Write-Host "${ANSI.RED}Ã— Source path cannot be empty${ANSI.RESET}"
        return
    }
    
    if (-not (Test-Path $sourcePath)) {
        Write-Host "${ANSI.RED}Ã— Source folder not found: $sourcePath${ANSI.RESET}"
        return
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter backup destination:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $destPath = Read-Host
    
    if ([string]::IsNullOrWhiteSpace($destPath)) {
        Write-Host "${ANSI.RED}Ã— Destination path cannot be empty${ANSI.RESET}
```