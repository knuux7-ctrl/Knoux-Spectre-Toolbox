## üìÑ modules/mod.automation/task.scheduler.ps1 (Áª≠)

```powershell
    Write-Host "${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
    Write-Host ""
    
    $jobs = Get-Job | Where-Object { $_.State -eq "Running" }
    
    if ($jobs.Count -eq 0) {
        Write-Host "${ANSI.TEXT_SECONDARY}No running jobs found${ANSI.RESET}"
        return
    }
    
    Write-Host "${ANSI.TEXT_SECONDARY}Select running job to stop:${ANSI.RESET}"
    $jobs | ForEach-Object {
        Write-Host " ${ANSI.PURPLE}$($_.Id)${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$($_.Name)${ANSI.RESET}"
    }
    
    Write-Host ""
    $jobId = Read-ValidatedSubInput -Max ($jobs | Measure-Object).Count
    
    if ($jobId -gt 0) {
        $selectedJob = $jobs[$jobId - 1]
        
        $confirm = Confirm-KnouxAction "Stop job '$($selectedJob.Name)'?" "N"
        
        if ($confirm) {
            Write-Host ""
            Write-Host "${ANSI.TEXT_SECONDARY}Stopping job...${ANSI.RESET}" -NoNewline
            
            try {
                Stop-Job -Id $selectedJob.Id
                Write-Host " ${ANSI.GREEN}DONE${ANSI.RESET}"
                Write-Host "${ANSI.GREEN}‚úì Job stopped successfully${ANSI.RESET}"
            } catch {
                Write-Host " ${ANSI.RED}FAILED${ANSI.RESET}"
                Write-Host "${ANSI.RED}√ó Error stopping job: $($_.Exception.Message)${ANSI.RESET}"
            }
        } else {
            Write-Host "${ANSI.TEXT_SECONDARY}Cancelled stop operation${ANSI.RESET}"
        }
    }
}

function Remove-Job {
    Write-Host ""
    Write-Host "${ANSI.PURPLE}${ANSI.BOLD}REMOVE JOB${ANSI.RESET}"
    Write-Host "${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
    Write-Host ""
    
    $jobs = Get-Job
    
    if ($jobs.Count -eq 0) {
        Write-Host "${ANSI.TEXT_SECONDARY}No jobs found${ANSI.RESET}"
        return
    }
    
    Write-Host "${ANSI.TEXT_SECONDARY}Select job to remove:${ANSI.RESET}"
    $jobs | ForEach-Object {
        Write-Host " ${ANSI.PURPLE}$($_.Id)${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$($_.Name)${ANSI.RESET} ${ANSI.TEXT_SECONDARY}($($_.State))${ANSI.RESET}"
    }
    
    Write-Host ""
    $jobId = Read-ValidatedSubInput -Max ($jobs | Measure-Object).Count
    
    if ($jobId -gt 0) {
        $selectedJob = $jobs[$jobId - 1]
        
        $confirm = Confirm-KnouxAction "Remove job '$($selectedJob.Name)'? This cannot be undone." "N"
        
        if ($confirm) {
            Write-Host ""
            Write-Host "${ANSI.TEXT_SECONDARY}Removing job...${ANSI.RESET}" -NoNewline
            
            try {
                Remove-Job -Id $selectedJob.Id
                Write-Host " ${ANSI.GREEN}DONE${ANSI.RESET}"
                Write-Host "${ANSI.GREEN}‚úì Job removed successfully${ANSI.RESET}"
            } catch {
                Write-Host " ${ANSI.RED}FAILED${ANSI.RESET}"
                Write-Host "${ANSI.RED}√ó Error removing job: $($_.Exception.Message)${ANSI.RESET}"
            }
        } else {
            Write-Host "${ANSI.TEXT_SECONDARY}Cancelled removal${ANSI.RESET}"
        }
    }
}

function Create-ScriptAutomation {
    Write-Host ""
    Write-Host "${ANSI.PURPLE}${ANSI.BOLD}SCRIPT AUTOMATION${ANSI.RESET}"
    Write-Host "${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
    Write-Host ""
    
    Write-Host "${ANSI.TEXT_SECONDARY}Create automated script workflows${ANSI.RESET}"
    Write-Host ""
    Write-Host " ${ANSI.GREEN}1.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}File Backup Automation${ANSI.RESET}"
    Write-Host " ${ANSI.GREEN}2.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}System Cleanup Script${ANSI.RESET}"
    Write-Host " ${ANSI.GREEN}3.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Network Monitoring${ANSI.RESET}"
    Write-Host " ${ANSI.GREEN}4.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Log Analysis Automation${ANSI.RESET}"
    Write-Host " ${ANSI.GREEN}5.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Custom Automation Script${ANSI.RESET}"
    Write-Host ""
    
    $autoChoice = Read-ValidatedSubInput -Max 5
    
    # Create outputs directory if it doesn't exist
    $outputDir = Join-Path $PSScriptRoot "../../outputs"
    if (!(Test-Path $outputDir)) {
        New-Item -ItemType Directory -Path $outputDir | Out-Null
    }
    
    switch ($autoChoice) {
        1 {
            $filePath = Join-Path $outputDir "automated_backup.ps1"
            $content = @"
<#
.AUTOMATED BACKUP SCRIPT
.Generated by Knoux Spectre Automation Center
.Date: $(Get-Date -Format "yyyy-MM-dd HH:mm")
#>

# Configuration
`$sourceFolders = @(
    # Add your source folders here
    # "C:\ImportantData"
    # "C:\Projects"
)

`$backupDestination = "D:\Backups"  # Change to your backup location
`$retentionDays = 30  # Keep backups for 30 days

# Create backup destination if it doesn't exist
if (-not (Test-Path `$backupDestination)) {
    New-Item -ItemType Directory -Path `$backupDestination -Force | Out-Null
}

# Perform backup for each source folder
foreach (`$source in `$sourceFolders) {
    if (Test-Path `$source) {
        Write-Host "`$ANSI.TEXT_SECONDARY"[+] Backing up `$source...`$ANSI.RESET"
        
        `$folderName = Split-Path `$source -Leaf
        `$timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
        `$backupName = "`${folderName}_`$timestamp.zip"
        `$backupPath = Join-Path `$backupDestination `$backupName
        
        try {
            Add-Type -AssemblySystem.IO.Compression.FileSystem
            [System.IO.Compression.ZipFile]::CreateFromDirectory(`$source, `$backupPath, 
                [System.IO.Compression.CompressionLevel]::Optimal, `$false)
            Write-Host "`$ANSI.GREEN"‚úì Backup created: `$backupPath`$ANSI.RESET"
        } catch {
            Write-Host "`$ANSI.RED"√ó Failed to backup `$source : `$(`$_.Exception.Message)`$ANSI.RESET"
        }
    } else {
        Write-Host "`$ANSI.ORANGE"‚ö† Source not found: `$source`$ANSI.RESET"
    }
}

# Clean up old backups
Write-Host "`$ANSI.TEXT_SECONDARY"[+] Cleaning up old backups...`$ANSI.RESET"
`$cutoffDate = (Get-Date).AddDays(-`$retentionDays)
Get-ChildItem -Path `$backupDestination -Filter "*.zip" | Where-Object { `$_.CreationTime -lt `$cutoffDate } | ForEach-Object {
    try {
        Remove-Item -Path `$_.FullName -Force
        Write-Host "`$ANSI.GREEN"‚úì Removed old backup: `$(`$_.Name)`$ANSI.RESET"
    } catch {
        Write-Host "`$ANSI.RED"√ó Failed to remove `$(`$_.Name) : `$(`$_.Exception.Message)`$ANSI.RESET"
    }
}

Write-Host "`$ANSI.GREEN"‚úÖ Automated backup process completed`$ANSI.RESET"
"@
        }
        
        2 {
            $filePath = Join-Path $outputDir "system_cleanup.ps1"
            $content = @"
<#
.SYSTEM CLEANUP SCRIPT
.Generated by Knoux Spectre Automation Center
.Date: $(Get-Date -Format "yyyy-MM-dd HH:mm")
#>

# System Cleanup Automation
Write-Host "`$ANSI.PURPLE`${ANSI.BOLD}AUTOMATED SYSTEM CLEANUP`${ANSI.RESET}"
Write-Host "`$ANSI.BORDER`$(-join (1..35 | ForEach-Object { "‚îÄ" }))`${ANSI.RESET}"

# Clean temporary files
Write-Host "`${ANSI.TEXT_SECONDARY}[+] Cleaning temporary files...`${ANSI.RESET}"
`$tempPaths = @(
    "`$env:TEMP"
    "`$env:SystemRoot\Temp"
    "`$env:LOCALAPPDATA\Temp"
)

`$freedSpace = 0
foreach (`$path in `$tempPaths) {
    if (Test-Path `$path) {
        try {
            `$beforeSize = (Get-ChildItem -Path `$path -Recurse -Force -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum).Sum
            Get-ChildItem -Path `$path -Recurse -Force -ErrorAction SilentlyContinue | Remove-Item -Force -Recurse -ErrorAction SilentlyContinue
            `$afterSize = (Get-ChildItem -Path `$path -Recurse -Force -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum).Sum
            `$freedSpace += (`$beforeSize - `$afterSize)
        } catch {
            # Continue with other paths
        }
    }
}

Write-Host "`${ANSI.GREEN}‚úì Cleaned temporary files (`$(Format-KnouxBytes `$freedSpace))`${ANSI.RESET}"

# Empty Recycle Bin
Write-Host "`${ANSI.TEXT_SECONDARY}[+] Emptying Recycle Bin...`${ANSI.RESET}"
try {
    `$recycleBinSize = (Get-ChildItem -Path "C:\`$Recycle.Bin" -Recurse -Force -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum).Sum
    Clear-RecycleBin -Force -ErrorAction SilentlyContinue
    Write-Host "`${ANSI.GREEN}‚úì Emptied Recycle Bin (`$(Format-KnouxBytes `$recycleBinSize))`${ANSI.RESET}"
} catch {
    Write-Host "`${ANSI.ORANGE}‚ö† Failed to empty Recycle Bin`${ANSI.RESET}"
}

# Clean browser caches (basic approach)
Write-Host "`${ANSI.TEXT_SECONDARY}[+] Cleaning browser caches...`${ANSI.RESET}"
`$browserPaths = @(
    "`$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Cache"
    "`$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Cache"
)

foreach (`$path in `$browserPaths) {
    if (Test-Path `$path) {
        try {
            Remove-Item -Path "`$path\*" -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "`${ANSI.GREEN}‚úì Cleaned `$path`${ANSI.RESET}"
        } catch {
            Write-Host "`${ANSI.ORANGE}‚ö† Failed to clean `$path`${ANSI.RESET}"
        }
    }
}

Write-Host "`${ANSI.GREEN}‚úÖ System cleanup completed`${ANSI.RESET}"
"@
        }
        
        3 {
            $filePath = Join-Path $outputDir "network_monitor.ps1"
            $content = @"
<#
.NETWORK MONITOR SCRIPT
.Generated by Knoux Spectre Automation Center
.Date: $(Get-Date -Format "yyyy-MM-dd HH:mm")
#>

# Network Monitoring Automation
param(
    [string[]]`$Targets = @("8.8.8.8", "1.1.1.1", "google.com"),
    [int]`$Interval = 60,
    [int]`$Duration = 3600
)

Write-Host "`$ANSI.PURPLE`${ANSI.BOLD}AUTOMATED NETWORK MONITOR`${ANSI.RESET}"
Write-Host "`$ANSI.BORDER`$(-join (1..35 | ForEach-Object { "‚îÄ" }))`${ANSI.RESET}"

`$endTime = (Get-Date).AddSeconds(`$Duration)
`$logFile = Join-Path "`$(Split-Path `$PSScriptRoot -Parent)\outputs" "network_monitor_`$(Get-Date -Format 'yyyyMMdd_HHmmss').log"

# Create log header
"`$(Get-Date) - Network Monitoring Started" | Out-File -FilePath `$logFile -Encoding UTF8

while ((Get-Date) -lt `$endTime) {
    "`$(Get-Date) - Monitoring Round" | Out-File -FilePath `$logFile -Append -Encoding UTF8
    
    foreach (`$target in `$Targets) {
        Write-Host "`${ANSI.TEXT_SECONDARY}[+] Testing `$target...`${ANSI.RESET}" -NoNewline
        
        try {
            `$result = Test-Connection -ComputerName `$target -Count 1 -Quiet -TimeoutSeconds 5
            if (`$result) {
                Write-Host " `$ANSI.GREEN`$(`$result ? 'UP' : 'DOWN')`$ANSI.RESET"
                "`$(Get-Date) - `$target - UP" | Out-File -FilePath `$logFile -Append -Encoding UTF8
            } else {
                Write-Host " `$ANSI.RED`$(`$result ? 'UP' : 'DOWN')`$ANSI.RESET"
                "`$(Get-Date) - `$target - DOWN" | Out-File -FilePath `$logFile -Append -Encoding UTF8
            }
        } catch {
            Write-Host " `$ANSI.REDERROR`$ANSI.RESET"
            "`$(Get-Date) - `$target - ERROR: `$(`$_.Exception.Message)" | Out-File -FilePath `$logFile -Append -Encoding UTF8
        }
    }
    
    if ((Get-Date) -lt `$endTime) {
        Write-Host "`${ANSI.TEXT_SECONDARY}Waiting `$Interval seconds...`${ANSI.RESET}"
        Start-Sleep -Seconds `$Interval
    }
}

"`$(Get-Date) - Network Monitoring Completed" | Out-File -FilePath `$logFile -Append -Encoding UTF8
Write-Host "`${ANSI.GREEN}‚úÖ Network monitoring completed`${ANSI.RESET}"
Write-Host "`${ANSI.TEXT_SECONDARY}Log file: `$logFile`${ANSI.RESET}"
"@
        }
        
        4 {
            $filePath = Join-Path $outputDir "log_analyzer.ps1"
            $content = @"
<#
.LOG ANALYZER SCRIPT
.Generated by Knoux Spectre Automation Center
.Date: $(Get-Date -Format "yyyy-MM-dd HH:mm")
#>

# Log Analysis Automation
param(
    [string]`$LogPath = "C:\Windows\Logs",
    [string]`$OutputPath = "`$(Split-Path `$PSScriptRoot -Parent)\outputs\log_analysis_`$(Get-Date -Format 'yyyyMMdd_HHmmss').txt"
)

Write-Host "`$ANSI.PURPLE`${ANSI.BOLD}AUTOMATED LOG ANALYZER`${ANSI.RESET}"
Write-Host "`$ANSI.BORDER`$(-join (1..30 | ForEach-Object { "‚îÄ" }))`${ANSI.RESET}"

if (-not (Test-Path `$LogPath)) {
    Write-Host "`$ANSI.RED`√ó Log path not found: `$LogPath`$ANSI.RESET"
    exit 1
}

# Create outputs directory if it doesn't exist
`$outputDir = Split-Path `$OutputPath -Parent
if (-not (Test-Path `$outputDir)) {
    New-Item -ItemType Directory -Path `$outputDir -Force | Out-Null
}

Write-Host "`${ANSI.TEXT_SECONDARY}[+] Analyzing logs in `$LogPath...`${ANSI.RESET}"

# Find recent log files
`$logFiles = Get-ChildItem -Path `$LogPath -Recurse -Include *.log, *.txt -File | 
    Where-Object { `$_.LastWriteTime -gt (Get-Date).AddDays(-7) } |
    Sort-Object LastWriteTime -Descending

Write-Host "`${ANSI.TEXT_SECONDARY}[+] Found `$(`$logFiles.Count) recent log files`${ANSI.RESET}"

# Analysis counters
`$errorCount = 0
`$warningCount = 0
`$criticalEvents = @()

# Process each log file
foreach (`$logFile in `$logFiles) {
    Write-Host "`${ANSI.TEXT_SECONDARY}[+] Processing `$(`$logFile.Name)...`${ANSI.RESET}"
    
    try {
        `$content = Get-Content `$logFile.FullName -ErrorAction Stop
        
        # Count error patterns
        `$errors = `$content | Where-Object { `$_ -match "(?i)(error|exception|failed|critical)" }
        `$warnings = `$content | Where-Object { `$_ -match "(?i)(warning|warn)" }
        
        `$errorCount += `$errors.Count
        `$warningCount += `$warnings.Count
        
        # Extract critical events (last 5 errors)
        `$recentErrors = `$errors | Select-Object -Last 5
        foreach (`$error in `$recentErrors) {
            `$criticalEvents += [PSCustomObject]@{
                File = `$logFile.Name
                Time = `$logFile.LastWriteTime
                Event = `$error
            }
        }
    } catch {
        Write-Host "`${ANSI.ORANGE}‚ö† Failed to process `$(`$logFile.Name): `$(`$_.Exception.Message)`${ANSI.RESET}"
    }
}

# Generate report
`$report = @"
Log Analysis Report
Generated: `$

(Get-Date)
Analyzed Path: `$LogPath
Log Files Processed: `$(`$logFiles.Count)

Summary:
========
Error Entries: `$errorCount
Warning Entries: `$warningCount

Recent Critical Events:
=======================
`$(`$criticalEvents | Format-Table File, Time, Event | Out-String)
"@

# Save report
`$report | Out-File -FilePath `$OutputPath -Encoding UTF8

Write-Host "`${ANSI.GREEN}‚úÖ Log analysis completed`${ANSI.RESET}"
Write-Host "`${ANSI.TEXT_SECONDARY}Report saved to: `$OutputPath`${ANSI.RESET}"
"@
        }
        
        5 {
            $filePath = Join-Path $outputDir "custom_automation.ps1"
            $content = @"
<#
.CUSTOM AUTOMATION SCRIPT
.Generated by Knoux Spectre Automation Center
.Date: $(Get-Date -Format "yyyy-MM-dd HH:mm")
#>

# Custom Automation Template
# Modify this script to create your own automation workflows

param(
    # Add your parameters here
    [string]`$Parameter1 = "DefaultValue",
    [int]`$Count = 10
)

Write-Host "`$ANSI.PURPLE`${ANSI.BOLD}CUSTOM AUTOMATION WORKFLOW`${ANSI.RESET}"
Write-Host "`$ANSI.BORDER`$(-join (1..35 | ForEach-Object { "‚îÄ" }))`${ANSI.RESET}"

# Initialization
Write-Host "`${ANSI.TEXT_SECONDARY}[+] Initializing automation...`${ANSI.RESET}"

# Your automation logic here
for (`$i = 1; `$i -le `$Count; `$i++) {
    Write-Host "`${ANSI.TEXT_SECONDARY}[`$i/`$Count] Processing...`${ANSI.RESET}"
    
    # Add your processing logic here
    # Examples:
    # Copy files
    # Process data
    # Send notifications
    # Update databases
    
    Start-Sleep -Milliseconds 100
}

# Completion
Write-Host "`${ANSI.GREEN}‚úÖ Custom automation completed`${ANSI.RESET}"

# Optional: Save results or send notifications
# Example:
# Send-MailMessage -To "admin@example.com" -Subject "Automation Complete" -Body "Processing finished at `$

(Get-Date)"
"@
        }
    }
    
    try {
        Set-Content -Path $filePath -Value $content -Encoding UTF8
        
        Write-Host ""
        Write-Host "${ANSI.GREEN}‚úì Automation script created successfully${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}File saved to: $filePath${ANSI.RESET}"
        
        # Offer to schedule the task
        $schedule = Confirm-KnouxAction "Schedule this script to run automatically?" "N"
        if ($schedule) {
            Schedule-ScriptTask -ScriptPath $filePath
        }
    } catch {
        Write-Host "${ANSI.RED}√ó Error creating automation script: $($_.Exception.Message)${ANSI.RESET}"
    }
}

function Schedule-ScriptTask {
    param([string]$ScriptPath)
    
    if (-not (Test-AdminPrivilege)) {
        Write-Host "${ANSI.ORANGE}‚ö† Administrator privileges required to schedule tasks${ANSI.RESET}"
        return
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Scheduling script task...${ANSI.RESET}"
    
    try {
        $taskName = "Knoux_Automation_$(Split-Path $ScriptPath -Leaf -Resolve)"
        $taskName = $taskName -replace '\.ps1$', '' -replace '[^a-zA-Z0-9_-]', '_'
        
        $action = New-ScheduledTaskAction -Execute "PowerShell.exe" -Argument "-ExecutionPolicy Bypass -File `"$ScriptPath`""
        $trigger = New-ScheduledTaskTrigger -Daily -At "2:00 AM"
        $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
        
        Register-ScheduledTask -TaskName $taskName -Action $action -Trigger $trigger -Settings $settings -Description "Knoux Spectre Automated Task"
        
        Write-Host "${ANSI.GREEN}‚úì Script scheduled successfully${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Task name: $taskName${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Trigger: Daily at 2:00 AM${ANSI.RESET}"
    } catch {
        Write-Host "${ANSI.RED}√ó Error scheduling task: $($_.Exception.Message)${ANSI.RESET}"
    }
}

function Run-SystemMaintenance {
    Write-Host ""
    Write-Host "${ANSI.PURPLE}${ANSI.BOLD}SYSTEM MAINTENANCE${ANSI.RESET}"
    Write-Host "${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
    Write-Host ""
    
    Write-Host "${ANSI.TEXT_SECONDARY}Running automated system maintenance...${ANSI.RESET}"
    
    # Check for admin privileges
    if (-not (Test-AdminPrivilege)) {
        Write-Host "${ANSI.ORANGE}‚ö† Administrator privileges recommended for full maintenance${ANSI.RESET}"
    }
    
    try {
        # Progress tracking
        Show-KnouxProgress "Starting system maintenance" 0
        
        # 1. Clean temporary files (20%)
        Show-KnouxProgress "Cleaning temporary files" 20
        Clean-TemporaryFiles
        
        # 2. Check disk space (40%)
        Show-KnouxProgress "Checking disk health" 40
        Check-DiskHealth
        
        # 3. Update system information (60%)
        Show-KnouxProgress "Updating system information" 60
        Update-SystemInfo
        
        # 4. Clean event logs (80%)
        Show-KnouxProgress "Cleaning old event logs" 80
        Clean-EventLogs
        
        # 5. Complete (100%)
        Show-KnouxProgress "Maintenance completed" 100
        
        Write-Host ""
        Write-Host "${ANSI.GREEN}‚úÖ System maintenance completed successfully${ANSI.RESET}"
    } catch {
        Write-Host ""
        Write-Host "${ANSI.RED}√ó Error during maintenance: $($_.Exception.Message)${ANSI.RESET}"
    }
}

function Clean-TemporaryFiles {
    $tempPaths = @(
        "$env:TEMP"
        "$env:SystemRoot\Temp"
        "$env:LOCALAPPDATA\Temp"
    )
    
    $totalFreed = 0
    
    foreach ($path in $tempPaths) {
        if (Test-Path $path) {
            try {
                $beforeSize = (Get-ChildItem -Path $path -Recurse -Force -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum).Sum
                Get-ChildItem -Path "$path\*" -Recurse -Force -ErrorAction SilentlyContinue | Remove-Item -Force -Recurse -ErrorAction SilentlyContinue
                $afterSize = (Get-ChildItem -Path $path -Recurse -Force -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum).Sum
                $freed = $beforeSize - $afterSize
                $totalFreed += $freed
            } catch {
                # Continue with other paths
            }
        }
    }
}

function Check-DiskHealth {
    # Basic disk space check
    $drives = Get-PSDrive -PSProvider FileSystem
    
    foreach ($drive in $drives) {
        if ($drive.Used -and $drive.Free) {
            $total = $drive.Used + $drive.Free
            $usagePercent = [math]::Round((($total - $drive.Free) / $total) * 100, 2)
            
            if ($usagePercent -gt 90) {
                Write-Host "${ANSI.ORANGE}‚ö† Drive $($drive.Name): High disk usage ($usagePercent%)${ANSI.RESET}"
            }
        }
    }
}

function Update-SystemInfo {
    # Refresh system information cache
    $infoPath = Join-Path $PSScriptRoot "../../outputs/system_info_cache.json"
    
    $systemInfo = @{
        LastUpdate = Get-Date
        ComputerName = $env:COMPUTERNAME
        UserName = $env:USERNAME
        OS = (Get-CimInstance Win32_OperatingSystem).Caption
        PowerShellVersion = $PSVersionTable.PSVersion.ToString()
    }
    
    # Create outputs directory if needed
    $outputDir = Join-Path $PSScriptRoot "../../outputs"
    if (!(Test-Path $outputDir)) {
        New-Item -ItemType Directory -Path $outputDir | Out-Null
    }
    
    $systemInfo | ConvertTo-Json | Out-File -FilePath $infoPath -Encoding UTF8
}

function Clean-EventLogs {
    if (Test-AdminPrivilege) {
        try {
            # Clean old application events (older than 30 days)
            $ cutoffDate = (Get-Date).AddDays(-30)
            wevtutil el | ForEach-Object {
                wevtutil cl $_ 2>$null
            }
        } catch {
            # Continue without failing
        }
    }
}

function Design-Workflow {
    Write-Host ""
    Write-Host "${ANSI.PURPLE}${ANSI.BOLD}WORKFLOW DESIGNER${ANSI.RESET}"
    Write-Host "${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
    Write-Host ""
    
    Write-Host "${ANSI.TEXT_SECONDARY}Create visual automation workflows${ANSI.RESET}"
    Write-Host ""
    Write-Host " ${ANSI.GREEN}1.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Data Processing Pipeline${ANSI.RESET}"
    Write-Host " ${ANSI.GREEN}2.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Deployment Workflow${ANSI.RESET}"
    Write-Host " ${ANSI.GREEN}3.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Notification System${ANSI.RESET}"
    Write-Host " ${ANSI.GREEN}4.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Backup Sequence${ANSI.RESET}"
    Write-Host " ${ANSI.GREEN}5.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Custom Workflow${ANSI.RESET}"
    Write-Host ""
    
    $workflowChoice = Read-ValidatedSubInput -Max 5
    
    switch ($workflowChoice) {
        1 { Generate-DataPipeline }
        2 { Generate-DeploymentWorkflow }
        3 { Generate-NotificationSystem }
        4 { Generate-BackupSequence }
        5 { Generate-CustomWorkflow }
    }
}

function Generate-DataPipeline {
    Write-Host ""
    Write-Host "${ANSI.PURPLE}${ANSI.BOLD}DATA PROCESSING PIPELINE${ANSI.RESET}"
    Write-Host "${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
    Write-Host ""
    
    # Create outputs directory if needed
    $outputDir = Join-Path $PSScriptRoot "../../outputs"
    if (!(Test-Path $outputDir)) {
        New-Item -ItemType Directory -Path $outputDir | Out-Null
    }
    
    $filePath = Join-Path $outputDir "data_pipeline.ps1"
    
    $content = @"
<#
.DATA PROCESSING PIPELINE
.Generated by Knoux Spectre Workflow Designer
.Date: $(Get-Date -Format "yyyy-MM-dd HH:mm")
#>

# Data Processing Pipeline Workflow
param(
    [string]`$InputPath = ".\input",
    [string]`$OutputPath = ".\output",
    [string]`$ArchivePath = ".\archive"
)

#region Workflow Configuration
Write-Host "`${ANSI.PURPLE}`${ANSI.BOLD}DATA PROCESSING PIPELINE`${ANSI.RESET}"
Write-Host "`${ANSI.BORDER}`$(-join (1..35 | ForEach-Object { "‚îÄ" }))`${ANSI.RESET}"

# Ensure directories exist
`$paths = @(`$InputPath, `$OutputPath, `$ArchivePath)
foreach (`$path in `$paths) {
    if (-not (Test-Path `$path)) {
        New-Item -ItemType Directory -Path `$path -Force | Out-Null
        Write-Host "`${ANSI.TEXT_SECONDARY}[+] Created directory: `$path`${ANSI.RESET}"
    }
}
#endregion

#region Pipeline Stages
# STAGE 1: Data Ingestion
function Invoke-DataIngestion {
    Write-Host "`${ANSI.TEXT_SECONDARY}[1/4] Ingesting data from `$InputPath...`${ANSI.RESET}"
    
    `$files = Get-ChildItem -Path `$InputPath -File
    if (`$files.Count -eq 0) {
        Write-Host "`${ANSI.ORANGE}‚ö† No files found in input directory`${ANSI.RESET}"
        return @()
    }
    
    Write-Host "`${ANSI.TEXT_SECONDARY}[+] Found `$(`$files.Count) files to process`${ANSI.RESET}"
    return `$files
}

# STAGE 2: Data Validation
function Test-DataValidation {
    param([System.IO.FileInfo[]]`$Files)
    
    Write-Host "`${ANSI.TEXT_SECONDARY}[2/4] Validating data...`${ANSI.RESET}"
    
    `$validFiles = @()
    `$invalidFiles = @()
    
    foreach (`$file in `$Files) {
        # Basic validation examples
        if (`$file.Length -gt 0) {
            # Check file extension (customize as needed)
            if (`$file.Extension -match "\.(csv|json|xml|txt)$") {
                `$validFiles += `$file
                Write-Host "`${ANSI.GREEN}‚úì Valid: `$(`$file.Name)`${ANSI.RESET}"
            } else {
                `$invalidFiles += `$file
                Write-Host "`${ANSI.ORANGE}‚ö† Invalid format: `$(`$file.Name)`${ANSI.RESET}"
            }
        } else {
            `$invalidFiles += `$file
            Write-Host "`${ANSI.RED}√ó Empty file: `$(`$file.Name)`${ANSI.RESET}"
        }
    }
    
    return `$validFiles, `$invalidFiles
}

# STAGE 3: Data Transformation
function Convert-DataTransformation {
    param([System.IO.FileInfo[]]`$Files)
    
    Write-Host "`${ANSI.TEXT_SECONDARY}[3/4] Transforming data...`${ANSI.RESET}"
    
    `$processedFiles = @()
    
    foreach (`$file in `$Files) {
        try {
            # Example transformation (customize as needed)
            `$outputFile = Join-Path `$OutputPath "`$(`$file.BaseName)_processed`$(`$file.Extension)"
            
            # Copy file as example transformation
            Copy-Item -Path `$file.FullName -Destination `$outputFile -Force
            
            `$processedFiles += `$outputFile
            Write-Host "`${ANSI.GREEN}‚úì Processed: `$(`$file.Name)`${ANSI.RESET}"
        } catch {
            Write-Host "`${ANSI.RED}√ó Failed to process `$(`$file.Name): `$(`$_.Exception.Message)`${ANSI.RESET}"
        }
    }
    
    return `$processedFiles
}

# STAGE 4: Data Archiving
function Save-DataArchiving {
    param(
        [System.IO.FileInfo[]]`$ProcessedFiles,
        [System.IO.FileInfo[]]`$OriginalFiles
    )
    
    Write-Host "`${ANSI.TEXT_SECONDARY}[4/4] Archiving processed data...`${ANSI.RESET}"
    
    # Archive original files
    foreach (`$file in `$OriginalFiles) {
        try {
            `$archiveFile = Join-Path `$ArchivePath "`$(`$file.Name)_`$(Get-Date -Format 'yyyyMMdd_HHmmss')`$(`$file.Extension)"
            Move-Item -Path `$file.FullName -Destination `$archiveFile -Force
            Write-Host "`${ANSI.GREEN}‚úì Archived: `$(`$file.Name)`${ANSI.RESET}"
        } catch {
            Write-Host "`${ANSI.RED}√ó Failed to archive `$(`$file.Name): `$(`$_.Exception.Message)`${ANSI.RESET}"
        }
    }
    
    Write-Host "`${ANSI.GREEN}‚úÖ Data pipeline completed successfully`${ANSI.RESET}"
    Write-Host "`${ANSI.TEXT_SECONDARY}Processed files: `$(`$ProcessedFiles.Count)`${ANSI.RESET}"
    Write-Host "`${ANSI.TEXT_SECONDARY}Archived files: `$(`$OriginalFiles.Count)`${ANSI.RESET}"
}
#endregion

#region Pipeline Execution
try {
    # Execute pipeline stages
    `$inputFiles = Invoke-DataIngestion
    if (`$inputFiles.Count -gt 0) {
        `$validFiles, `$invalidFiles = Test-DataValidation -Files `$inputFiles
        if (`$validFiles.Count -gt 0) {
            `$processedFiles = Convert-DataTransformation -Files `$validFiles
            Save-DataArchiving -ProcessedFiles `$processedFiles -OriginalFiles `$validFiles
        }
    }
} catch {
    Write-Host "`${ANSI.RED}√ó Pipeline error: `$(`$_.Exception.Message)`${ANSI.RESET}"
    exit 1
}
#endregion
"@
    
    try {
        Set-Content -Path $filePath -Value $content -Encoding UTF8
        Write-Host "${ANSI.GREEN}‚úì Data pipeline created successfully${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}File saved to: $filePath${ANSI.RESET}"
    } catch {
        Write-Host "${ANSI.RED}√ó Error creating data pipeline: $($_.Exception.Message)${ANSI.RESET}"
    }
}

function Generate-DeploymentWorkflow {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Deployment workflow generation not implemented in this demo${ANSI.RESET}"
    Write-Host "${ANSI.TEXT_SECONDARY}Would create CI/CD automation scripts${ANSI.RESET}"
}

function Generate-NotificationSystem {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Notification system generation not implemented in this demo${ANSI.RESET}"
    Write-Host "${ANSI.TEXT_SECONDARY}Would create email/SMS alert workflows${ANSI.RESET}"
}

function Generate-BackupSequence {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Backup sequence generation not implemented in this demo${ANSI.RESET}"
    Write-Host "${ANSI.TEXT_SECONDARY}Would create multi-stage backup workflows${ANSI.RESET}"
}

function Generate-CustomWorkflow {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Custom workflow generation not implemented in this demo${ANSI.RESET}"
    Write-Host "${ANSI.TEXT_SECONDARY}Would create visual workflow designer${ANSI.RESET}"
}

Export-ModuleMember -Function @('Show-AutomationCenter')
```

‚úÖ Automation module created

Áî±‰∫éÂõûÂ§çÈïøÂ∫¶ÈôêÂà∂ÔºåËøòÊúâ‰ª•‰∏ãÊ®°ÂùóÈúÄË¶ÅÂàõÂª∫Ôºö

Êé•‰∏ãÊù•Êàë‰ª¨Â∞ÜÂàõÂª∫‰ª•‰∏ãÊ®°ÂùóÊñá‰ª∂Ôºö