## ðŸ“„ modules/mod.backup/folder.backup.ps1 (ç»­)

```powershell
        return
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter backup schedule:${ANSI.RESET}"
    Write-Host " ${ANSI.PURPLE}1${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Daily${ANSI.RESET}"
    Write-Host " ${ANSI.PURPLE}2${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Weekly${ANSI.RESET}"
    Write-Host " ${ANSI.PURPLE}3${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Monthly${ANSI.RESET}"
    Write-Host ""
    
    $scheduleChoice = Read-ValidatedSubInput -Max 3
    
    $schedule = switch ($scheduleChoice) {
        1 { "Daily" }
        2 { "Weekly" }
        3 { "Monthly" }
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter task name:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $taskName = Read-Host
    
    if ([string]::IsNullOrWhiteSpace($taskName)) {
        $taskName = "KnouxBackup_$(Split-Path $sourcePath -Leaf)_$(Get-Date -Format 'yyyyMMdd')"
    }
    
    # Sanitize task name
    $taskName = $taskName -replace '[^a-zA-Z0-9\-_]', '_'
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Creating scheduled backup task...${ANSI.RESET}"
    
    try {
        # Create backup script
        $scriptPath = Join-Path $PSScriptRoot "../../outputs/backup_$taskName.ps1"
        
        # Create outputs directory if it doesn't exist
        $outputDir = Join-Path $PSScriptRoot "../../outputs"
        if (!(Test-Path $outputDir)) {
            New-Item -ItemType Directory -Path $outputDir | Out-Null
        }
        
        # Generate backup script content
        $scriptContent = @"
# Scheduled Backup Script for $taskName
# Generated by Knoux Spectre Toolbox
# Date: $(Get-Date)

`$sourcePath = "$sourcePath"
`$destPath = "$destPath"
`$backupName = "$(Split-Path $sourcePath -Leaf)"

# Load Knoux helpers if available
if (Test-Path "$PSScriptRoot/../../lib/helper.functions.ps1") {
    . "$PSScriptRoot/../../lib/helper.functions.ps1"
}

# Create destination if it doesn't exist
if (-not (Test-Path `$destPath)) {
    New-Item -ItemType Directory -Path `$destPath -Force | Out-Null
}

# Create backup with timestamp
`$timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
`$backupFileName = "`${backupName}_`$timestamp.zip"
`$backupFilePath = Join-Path `$destPath `$backupFileName

try {
    # Compress folder
    Add-Type -AssemblySystem.IO.Compression.FileSystem
    [System.IO.Compression.ZipFile]::CreateFromDirectory(`$sourcePath, `$backupFilePath, 
        [System.IO.Compression.CompressionLevel]::Optimal, `$false)
    
    # Log success
    `$logMessage = "[$(Get-Date)] Backup successful: `$backupFilePath"
    Add-Content -Path "$outputDir/backup_log.txt" -Value `$logMessage
    
    # Clean up old backups (keep last 10)
    `$backups = Get-ChildItem -Path `$destPath -Filter "`${backupName}_*.zip" | 
        Sort-Object LastWriteTime -Descending | Select-Object -Skip 10
    
    foreach (`$backup in `$backups) {
        Remove-Item -Path `$backup.FullName -Force
    }
} catch {
    # Log error
    `$logMessage = "[$(Get-Date)] Backup failed: `$(`$_.Exception.Message)"
    Add-Content -Path "$outputDir/backup_log.txt" -Value `$logMessage
}
"@
        
        Set-Content -Path $scriptPath -Value $scriptContent -Encoding UTF8
        
        # Create scheduled task (Windows only)
        if ($env:OS -eq "Windows_NT") {
            $action = New-ScheduledTaskAction -Execute "PowerShell.exe" -Argument "-ExecutionPolicy Bypass -File `"$scriptPath`""
            $trigger = switch ($schedule) {
                "Daily" { New-ScheduledTaskTrigger -Daily -At "2:00 AM" }
                "Weekly" { New-ScheduledTaskTrigger -Weekly -DaysOfWeek Sunday -At "3:00 AM" }
                "Monthly" { New-ScheduledTaskTrigger -Weekly -WeeksInterval 4 -DaysOfWeek Sunday -At "4:00 AM" }
            }
            
            $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
            $principal = New-ScheduledTaskPrincipal -UserId "$env:USERDOMAIN\$env:USERNAME" -LogonType Interactive
            
            Register-ScheduledTask -TaskName $taskName -Action $action -Trigger $trigger -Settings $settings -Principal $principal -Description "Knoux Spectre Backup Task" -ErrorAction Stop
            
            Write-Host "${ANSI.GREEN}âœ“ Scheduled backup task created successfully${ANSI.RESET}"
            Write-Host "${ANSI.TEXT_SECONDARY}Task name: $taskName${ANSI.RESET}"
            Write-Host "${ANSI.TEXT_SECONDARY}Schedule: $schedule${ANSI.RESET}"
            Write-Host "${ANSI.TEXT_SECONDARY}Script: $scriptPath${ANSI.RESET}"
            Write-Host "${ANSI.TEXT_SECONDARY}Manage this task in Task Scheduler${ANSI.RESET}"
        } else {
            Write-Host "${ANSI.ORANGE}âš  Scheduled tasks not supported on this OS${ANSI.RESET}"
            Write-Host "${ANSI.TEXT_SECONDARY}Script created at: $scriptPath${ANSI.RESET}"
            Write-Host "${ANSI.TEXT_SECONDARY}You can set up cron jobs or other schedulers manually${ANSI.RESET}"
        }
    } catch {
        Write-Host "${ANSI.RED}Ã— Error creating scheduled backup: $($_.Exception.Message)${ANSI.RESET}"
    }
}

function Backup-SystemState {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}System state backup requires Windows Backup or third-party tools${ANSI.RESET}"
    Write-Host "${ANSI.TEXT_SECONDARY}This feature would create a complete system recovery point${ANSI.RESET}"
    Write-Host ""
    
    Write-Host "${ANSI.TEXT_SECONDARY}Options:${ANSI.RESET}"
    Write-Host " ${ANSI.GREEN}1.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Create Windows System Restore Point${ANSI.RESET}"
    Write-Host " ${ANSI.GREEN}2.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Backup Registry Hives${ANSI.RESET}"
    Write-Host " ${ANSI.GREEN}3.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Export Group Policy Settings${ANSI.RESET}"
    Write-Host ""
    
    $choice = Read-ValidatedSubInput -Max 3
    
    switch ($choice) {
        1 { Create-SystemRestorePoint }
        2 { Backup-RegistryHives }
        3 { Export-GroupPolicy }
    }
}

function Create-SystemRestorePoint {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Creating system restore point...${ANSI.RESET}"
    
    if (-not (Test-AdminPrivilege)) {
        Write-Host "${ANSI.ORANGE}âš  Administrator privileges required${ANSI.RESET}"
        return
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter description for restore point:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $description = Read-Host
    
    if ([string]::IsNullOrWhiteSpace($description)) {
        $description = "Knoux Spectre Backup $(Get-Date -Format 'yyyy-MM-dd HH:mm')"
    }
    
    try {
        # Check if checkpoints are enabled
        $checkpointEnabled = (Get-ComputerInfo).SystemBootConfiguration.CheckpointEnabled
        
        if (-not $checkpointEnabled) {
            Write-Host "${ANSI.ORANGE}âš  System Restore may not be enabled${ANSI.RESET}"
            $enableRestore = Confirm-KnouxAction "Attempt to enable System Restore?" "N"
            
            if ($enableRestore) {
                Enable-ComputerRestore -Drive "$env:SystemDrive\" -ErrorAction Stop
                Write-Host "${ANSI.GREEN}âœ“ System Restore enabled${ANSI.RESET}"
            } else {
                Write-Host "${ANSI.TEXT_SECONDARY}Cancelled operation${ANSI.RESET}"
                return
            }
        }
        
        # Create restore point
        Show-KnouxProgress "Creating restore point" 0
        $result =Checkpoint-Computer -Description $description -RestorePointType "MODIFY_SETTINGS" -ErrorAction Stop
        
        Write-Host ""
        Write-Host "${ANSI.GREEN}âœ“ System restore point created successfully${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Description: $description${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Time: $(Get-Date)${ANSI.RESET}"
    } catch {
        Write-Host "${ANSI.RED}Ã— Error creating restore point: $($_.Exception.Message)${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Ensure System Restore is enabled for your drive${ANSI.RESET}"
    }
}

function Backup-RegistryHives {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Backing up registry hives...${ANSI.RESET}"
    
    if (-not (Test-AdminPrivilege)) {
        Write-Host "${ANSI.ORANGE}âš  Administrator privileges required${ANSI.RESET}"
        return
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter backup destination:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $destPath = Read-Host
    
    if ([string]::IsNullOrWhiteSpace($destPath)) {
        Write-Host "${ANSI.RED}Ã— Destination path cannot be empty${ANSI.RESET}"
        return
    }
    
    # Create destination if it doesn't exist
    if (-not (Test-Path $destPath)) {
        try {
            New-Item -ItemType Directory -Path $destPath -Force | Out-Null
        } catch {
            Write-Host "${ANSI.RED}Ã— Failed to create directory: $($_.Exception.Message)${ANSI.RESET}"
            return
        }
    }
    
    # Registry hives to backup
    $hives = @{
        "HKEY_LOCAL_MACHINE\SOFTWARE" = "SOFTWARE.hiv"
        "HKEY_LOCAL_MACHINE\SYSTEM" = "SYSTEM.hiv"
        "HKEY_CURRENT_USER" = "NTUSER.DAT"
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Backing up registry hives...${ANSI.RESET}"
    
    $successCount = 0
    $failCount = 0
    
    foreach ($hive in $hives.Keys) {
        $fileName = $hives[$hive]
        $filePath = Join-Path $destPath $fileName
        
        Write-Host "${ANSI.TEXT_SECONDARY}Backing up $hive...${ANSI.RESET}" -NoNewline
        
        try {
            # Use reg.exe to export hive
            $process = Start-Process -FilePath "reg" -ArgumentList "export", "`"$hive`"", "`"$filePath`"", "/y" -NoNewWindow -PassThru -Wait
            
            if ($process.ExitCode -eq 0) {
                Write-Host " ${ANSI.GREEN}DONE${ANSI.RESET}"
                $successCount++
            } else {
                Write-Host " ${ANSI.RED}FAILED${ANSI.RESET}"
                $failCount++
            }
        } catch {
            Write-Host " ${ANSI.RED}FAILED${ANSI.RESET}"
            $failCount++
        }
    }
    
    Write-Host ""
    Write-Host "${ANSI.GREEN}âœ“ $successCount hive(s) backed up successfully${ANSI.RESET}"
    if ($failCount -gt 0) {
        Write-Host "${ANSI.RED}Ã— $failCount hive(s) failed to backup${ANSI.RESET}"
    }
    
    Write-Host "${ANSI.TEXT_SECONDARY}Files saved to: $destPath${ANSI.RESET}"
}

function Export-GroupPolicy {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Exporting Group Policy settings...${ANSI.RESET}"
    
    if (-not (Test-AdminPrivilege)) {
        Write-Host "${ANSI.ORANGE}âš  Administrator privileges required${ANSI.RESET}"
        return
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}This will export local group policy settings${ANSI.RESET}"
    
    try {
        # Create output directory
        $outputDir = Join-Path $PSScriptRoot "../../outputs/gpo_backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
        New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
        
        # Export GPOs (this is a simplified approach)
        Write-Host "${ANSI.TEXT_SECONDARY}Exporting Local Group Policy...${ANSI.RESET}"
        
        # Backup registry keys related to Group Policy
        $gpoKeys = @(
            "HKEY_LOCAL_MACHINE\SOFTWARE\Policies",
            "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy",
            "HKEY_CURRENT_USER\Software\Policies"
        )
        
        foreach ($key in $gpoKeys) {
            $fileName = ($key -replace 'HKEY_LOCAL_MACHINE\\', '' -replace 'HKEY_CURRENT_USER\\', '' -replace '\\', '_') + ".reg"
            $filePath = Join-Path $outputDir $fileName
            
            Write-Host "${ANSI.TEXT_SECONDARY}Exporting $key...${ANSI.RESET}" -NoNewline
            
            try {
                $process = Start-Process -FilePath "reg" -ArgumentList "export", "`"$key`"", "`"$filePath`"", "/y" -NoNewWindow -PassThru -Wait
                
                if ($process.ExitCode -eq 0) {
                    Write-Host " ${ANSI.GREEN}DONE${ANSI.RESET}"
                } else {
                    Write-Host " ${ANSI.RED}FAILED${ANSI.RESET}"
                }
            } catch {
                Write-Host " ${ANSI.RED}FAILED${ANSI.RESET}"
            }
        }
        
        Write-Host ""
        Write-Host "${ANSI.GREEN}âœ“ Group Policy export completed${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Files saved to: $outputDir${ANSI.RESET}"
    } catch {
        Write-Host "${ANSI.RED}Ã— Error exporting Group Policy: $($_.Exception.Message)${ANSI.RESET}"
    }
}

Export-ModuleMember -Function @('Show-BackupUtility')
```

âœ… Backup & Restore module created

---
## ðŸ“œ SCRIPT GENERATOR MODULE

ðŸ“„ Creating `modules/mod.scriptgen/batch.builder.ps1`:

```powershell
<#
.SYNOPSIS
    Knoux Spectre Script Generator
.DESCRIPTION
    Interactive script builder for various scripting languages
.AUTHOR
    Knoux Systems
.VERSION
    1.0.0
#>

function Show-ScriptGenerator {
    [CmdletBinding()]
    param()
    
    Clear-ScreenWithBackground
    Write-Host "${ANSI.BG_DARK}${ANSI.PURPLE}${ANSI.BOLD}ðŸ“œ SCRIPT GENERATOR${ANSI.RESET}"
    Write-Host "${ANSI.BORDER}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${ANSI.RESET}"
    Write-Host ""
    
    do {
        Write-Host "${ANSI.TEXT_SECONDARY}Script Generator Options:${ANSI.RESET}"
        Write-Host " ${ANSI.PURPLE}1${ANSI.RESET} ${ANSI.TEXT_PRIMARY}PowerShell Script Builder${ANSI.RESET}"
        Write-Host " ${ANSI.PURPLE}2${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Batch File Builder${ANSI.RESET}"
        Write-Host " ${ANSI.PURPLE}3${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Python Script Builder${ANSI.RESET}"
        Write-Host " ${ANSI.PURPLE}4${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Template Library${ANSI.RESET}"
        Write-Host " ${ANSI.PURPLE}5${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Code Snippet Manager${ANSI.RESET}"
        Write-Host ""
        Write-Host " ${ANSI.RED}0${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Back to Menu${ANSI.RESET}"
        Write-Host ""
        
        $choice = Read-ValidatedSubInput -Max 5
        
        switch ($choice) {
            0 { return }
            1 { Build-PowerShellScript }
            2 { Build-BatchScript }
            3 { Build-PythonScript }
            4 { Show-TemplateLibrary }
            5 { Show-CodeSnippets }
        }
        
        Write-Host ""
        Write-Host "${ANSI.TEXT_SECONDARY}Press any key to continue...${ANSI.RESET}"
        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
        Clear-ScreenWithBackground
        
    } while ($true)
}

function Build-PowerShellScript {
    Write-Host ""
    Write-Host "${ANSI.PURPLE}${ANSI.BOLD}POWERShell SCRIPT BUILDER${ANSI.RESET}"
    Write-Host "${ANSI.BORDER}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${ANSI.RESET}"
    Write-Host ""
    
    Write-Host "${ANSI.TEXT_SECONDARY}Enter script name:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $scriptName = Read-Host
    
    if ([string]::IsNullOrWhiteSpace($scriptName)) {
        Write-Host "${ANSI.RED}Ã— Script name cannot be empty${ANSI.RESET}"
        return
    }
    
    # Ensure .ps1 extension
    if (-not $scriptName.EndsWith(".ps1")) {
        $scriptName = "$scriptName.ps1"
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter script description:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $description = Read-Host
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Select script type:${ANSI.RESET}"
    Write-Host " ${ANSI.PURPLE}1${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Basic Script${ANSI.RESET}"
    Write-Host " ${ANSI.PURPLE}2${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Function Script${ANSI.RESET}"
    Write-Host " ${ANSI.PURPLE}3${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Module Script${ANSI.RESET}"
    Write-Host ""
    
    $typeChoice = Read-ValidatedSubInput -Max 3
    
    # Create outputs directory if it doesn't exist
    $outputDir = Join-Path $PSScriptRoot "../../outputs"
    if (!(Test-Path $outputDir)) {
        New-Item -ItemType Directory -Path $outputDir | Out-Null
    }
    
    $filePath = Join-Path $outputDir $scriptName
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Building PowerShell script...${ANSI.RESET}"
    
    try {
        switch ($typeChoice) {
            1 {
                # Basic Script
                $content = @"
<#
.SYNOPSIS
    $description
.DESCRIPTION
    Generated by Knoux Spectre Script Generator
.CREATED
    $(Get-Date -Format "yyyy-MM-dd HH:mm")
.AUTHOR
    $env:USERNAME
#>

# Your PowerShell code goes here

Write-Host "`$ANSI.TEXT_SECONDARY"[+] Executing $scriptName...`$ANSI.RESET"

# Example:
# Get-Process | Select-Object -First 5 | Format-Table Name, Id, CPU

Write-Host "`$ANSI.GREEN"âœ… Script execution completed`$ANSI.RESET"
"@
            }
            
            2 {
                # Function Script
                $funcName = ($scriptName -replace '\.ps1$', '') -replace '[^a-zA-Z0-9]', ''
                $content = @"
<#
.SYNOPSIS
    $description
.DESCRIPTION
    Generated by Knoux Spectre Script Generator
.CREATED
    $(Get-Date -Format "yyyy-MM-dd HH:mm")
.AUTHOR
    $env:USERNAME
#>

function $funcName {
    [CmdletBinding()]
    param(
        # Add your parameters here
        #[Parameter(Mandatory=`$true)]
        #[string]`$Parameter1
    )
    
    begin {
        Write-Verbose "Starting $funcName"
    }
    
    process {
        # Your function logic here
        Write-Host "`$ANSI.TEXT_SECONDARY"[+] Running $funcName...`$ANSI.RESET"
    }
    
    end {
        Write-Verbose "$funcName completed"
    }
}

# Export the function
Export-ModuleMember -Function $funcName
"@
            }
            
            3 {
                # Module Script
                $moduleName = ($scriptName -replace '\.ps1$', '')
                $content = @"
<#
.SYNOPSIS
    $description
.DESCRIPTION
    Generated by Knoux Spectre Script Generator
.MODULE
    $moduleName
.VERSION
    1.0.0
.AUTHOR
    $env:USERNAME
.CREATED
    $(Get-Date -Format "yyyy-MM-dd HH:mm")
#>

# Module variables
`$Script:ModuleName = "$moduleName"
`$Script:Version = "1.0.0"

# Module functions
function Get-$moduleName {
    [CmdletBinding()]
    param()
    
    Write-Host "`$ANSI.TEXT_SECONDARY"[+] Retrieving $moduleName information...`$ANSI.RESET"
    Write-Output @{
        Name = `$Script:ModuleName
        Version = `$Script:Version
        Author = "$env:USERNAME"
        Created = "$(Get-Date -Format "yyyy-MM-dd HH:mm")"
    }
}

function Set-$moduleName {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=`$true)]
        [string]`$Setting
    )
    
    Write-Host "`$ANSI.TEXT_SECONDARY"[+] Setting $moduleName configuration: `$Setting`$ANSI.RESET"
}

# Export functions
Export-ModuleMember -Function @('Get-$moduleName', 'Set-$moduleName')
"@
            }
        }
        
        # Save the script
        Set-Content -Path $filePath -Value $content -Encoding UTF8
        
        Write-Host ""
        Write-Host "${ANSI.GREEN}âœ“ PowerShell script created successfully${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}File saved to: $filePath${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Tip: Edit with 'ii $filePath'${ANSI.RESET}"
        
        # Offer to open in editor
        $openEditor = Confirm-KnouxAction "Open script in editor?" "N"
        if ($openEditor) {
            powershell.exe -Command "ii '$filePath'"
        }
    } catch {
        Write-Host "${ANSI.RED}Ã— Error creating script: $($_.Exception.Message)${ANSI.RESET}"
    }
}

function Build-BatchScript {
    Write-Host ""
    Write-Host "${ANSI.PURPLE}${ANSI.BOLD}BATCH SCRIPT BUILDER${ANSI.RESET}"
    Write-Host "${ANSI.BORDER}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${ANSI.RESET}"
    Write-Host ""
    
    Write-Host "${ANSI.TEXT_SECONDARY}Enter script name:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $scriptName = Read-Host
    
    if ([string]::IsNullOrWhiteSpace($scriptName)) {
        Write-Host "${ANSI.RED}Ã— Script name cannot be empty${ANSI.RESET}"
        return
    }
    
    # Ensure .bat extension
    if (-not $scriptName.EndsWith(".bat")) {
        $scriptName = "$scriptName.bat"
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter script description:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $description = Read-Host
    
    # Create outputs directory if it doesn't exist
    $outputDir = Join-Path $PSScriptRoot "../../outputs"
    if (!(Test-Path $outputDir)) {
        New-Item -ItemType Directory -Path $outputDir | Out-Null
    }
    
    $filePath = Join-Path $outputDir $scriptName
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Building batch script...${ANSI.RESET}"
    
    try {
        $content = @"
@echo off
:: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
:: â”‚ $description                                        â”‚
:: â”‚ Generated by Knoux Spectre Script Generator          â”‚
:: â”‚ Date: $(Get-Date -Format "yyyy-MM-dd HH:mm")                                 â”‚
:: â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

setlocal enabledelayedexpansion

:: Console setup for UTF-8 support
chcp 65001 >nul

:: Script header
echo [38;2;156;163;175m[+] Executing $scriptName...[0m

:: Your batch code goes here
:: Example:
:: dir /b
:: echo Current user: %USERNAME%
:: timeout /t 2 /nobreak >nul

:: Completion message
echo [38;2;34;197;94mâœ… Script execution completed[0m
pause >nul
"@
        
        # Save the script
        Set-Content -Path $filePath -Value $content -Encoding UTF8
        
        Write-Host ""
        Write-Host "${ANSI.GREEN}âœ“ Batch script created successfully${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}File saved to: $filePath${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Tip: Double-click to run${ANSI.RESET}"
        
        # Offer to open in editor
        $openEditor = Confirm-KnouxAction "Open script in editor?" "N"
        if ($openEditor) {
            powershell.exe -Command "ii '$filePath'"
        }
    } catch {
        Write-Host "${ANSI.RED}Ã— Error creating script: $($_.Exception.Message)${ANSI.RESET}"
    }
}

function Build-PythonScript {
    Write-Host ""
    Write-Host "${ANSI.PURPLE}${ANSI.BOLD}PYTHON SCRIPT BUILDER${ANSI.RESET}"
    Write-Host "${ANSI.BORDER}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${ANSI.RESET}"
    Write-Host ""
    
    Write-Host "${ANSI.TEXT_SECONDARY}Enter script name:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $scriptName = Read-Host
    
    if ([string]::IsNullOrWhiteSpace($scriptName)) {
        Write-Host "${ANSI.RED}Ã— Script name cannot be empty${ANSI.RESET}"
        return
    }
    
    # Ensure .py extension
    if (-not $scriptName.EndsWith(".py")) {
        $scriptName = "$scriptName.py"
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter script description:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $description = Read-Host
    
    # Create outputs directory if it doesn't exist
    $outputDir = Join-Path $PSScriptRoot "../../outputs"
    if (!(Test-Path $outputDir)) {
        New-Item -ItemType Directory -Path $outputDir | Out-Null
    }
    
    $filePath = Join-Path $outputDir $scriptName
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Building Python script...${ANSI.RESET}"
    
    try {
        $content = @"
#!/usr/bin/env python3
"""
$description
Generated by Knoux Spectre Script Generator
Date: $(Get-Date -Format "yyyy-MM-dd HH:mm")
Author: $env:USERNAME
"""

import os
import sys
from datetime import datetime

def main():
    """Main function"""
    print("\\033[38;2;156;163;175m[+] Executing $scriptName...\\033[0m")
    
    # Your Python code goes here
    # Example:
    # print(f"Current working directory: {os.getcwd()}")
    # print(f"Python version: {sys.version}")
    
    print("\\033[38;2;34;197;94mâœ… Script execution completed\\033[0m")

if __name__ == "__main__":
    main()
"@
        
        # Save the script
        Set-Content -Path $filePath -Value $content -Encoding UTF8
        
        Write-Host ""
        Write-Host "${ANSI.GREEN}âœ“ Python script created successfully${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}File saved to: $filePath${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Tip: Run with 'python $filePath'${ANSI.RESET}"
        
        # Offer to open in editor
        $openEditor = Confirm-KnouxAction "Open script in editor?" "N"
        if ($openEditor) {
            powershell.exe -Command "ii '$filePath'"
        }
    } catch {
        Write-Host "${ANSI.RED}Ã— Error creating script: $($_.Exception.Message)${ANSI.RESET}"
    }
}

function Show-TemplateLibrary {
    Write-Host ""
    Write-Host "${ANSI.PURPLE}${ANSI.BOLD}TEMPLATE LIBRARY${ANSI.RESET}"
    Write-Host "${ANSI.BORDER}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${ANSI.RESET}"
    Write-Host ""
    
    Write-Host "${ANSI.TEXT_SECONDARY}Pre-built templates:${ANSI.RESET}"
    Write-Host " ${ANSI.GREEN}1.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}System Information Collector${ANSI.RESET}"
    Write-Host " ${ANSI.GREEN}2.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Network Scanner${ANSI.RESET}"
    Write-Host " ${ANSI.GREEN}3.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}File Organizer${ANSI.RESET}"
    Write-Host " ${ANSI.GREEN}4.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Log Parser${ANSI.RESET}"
    Write-Host " ${ANSI.GREEN}5.${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Process Monitor${ANSI.RESET}"
    Write-Host ""
    
    $templateChoice = Read-ValidatedSubInput -Max 5
    
    # Create outputs directory if it doesn't exist
    $outputDir = Join-Path $PSScriptRoot "../../outputs"
    if (!(Test-Path $outputDir)) {
        New-Item -ItemType Directory -Path $outputDir | Out-Null
    }
    
    switch ($templateChoice) {
        1 {
            $filePath = Join-Path $outputDir "sysinfo_collector.ps1"
            $content = @"
<#
.SYNOPSIS
    System Information Collector
.DESCRIPTION
    Collects comprehensive system information
.AUTHOR
    Knoux Spectre Toolbox
.CREATED
    $(Get-Date -Format "yyyy-MM-dd HH:mm")
#>

# System Information Collector Template
Write-Host "`$ANSI.PURPLE`${ANSI.BOLD}SYSTEM INFORMATION COLLECTOR`${ANSI.RESET}"
Write-Host "`$ANSI.BORDER`$(-join (1..40 | ForEach-Object { "â”€" }))`${ANSI.RESET}"

# Computer Information
`$computerInfo = Get-ComputerInfo
Write-Host "`${ANSI.TEXT_SECONDARY}Computer Name:`${ANSI.RESET} `$(`$computerInfo.CsName)"
Write-Host "`${ANSI.TEXT_SECONDARY}Manufacturer:`${ANSI.RESET} `$(`$computerInfo.CsManufacturer)"
Write-Host "`${ANSI.TEXT_SECONDARY}Model:`${ANSI.RESET} `$(`$computerInfo.CsModel)"

# OS Information
`$osInfo = Get-CimInstance Win32_OperatingSystem
Write-Host "`${ANSI.TEXT_SECONDARY}OS:`${ANSI.RESET} `$(`$osInfo.Caption)"
Write-Host "`${ANSI.TEXT_SECONDARY}Version:`${ANSI.RESET} `$(`$osInfo.Version)"

# CPU Information
`$cpuInfo = Get-CimInstance Win32_Processor
Write-Host "`${ANSI.TEXT_SECONDARY}CPU:`${ANSI.RESET} `$(`$cpuInfo.Name)"

# Memory Information
`$memoryInfo = Get-CimInstance Win32_PhysicalMemory
`$totalMemory = (`$memoryInfo | Measure-Object -Property Capacity -Sum).Sum / 1GB
Write-Host "`${ANSI.TEXT_SECONDARY}Memory:`${ANSI.RESET} `$([math]::Round(`$totalMemory, 2)) GB"

Write-Host "`${ANSI.GREEN}âœ… System information collection complete`${ANSI.RESET}"
"@
        }
        
        2 {
            $filePath = Join-Path $outputDir "network_scanner.ps1"
            $content = @"
<#
.SYNOPSIS
    Network Scanner
.DESCRIPTION
    Scans network for active devices
.AUTHOR
    Knoux Spectre Toolbox
.CREATED
    $(Get-Date -Format "yyyy-MM-dd HH:mm")
#>

# Network Scanner Template
param(
    [string]`$NetworkRange = "192.168.1",
    [int]`$Timeout = 100
)

Write-Host "`$ANSI.PURPLE`${ANSI.BOLD}NETWORK SCANNER`${ANSI.RESET}"
Write-Host "`$ANSI.BORDER`$(-join (1..30 | ForEach-Object { "â”€" }))`${ANSI.RESET}"
Write-Host "`${ANSI.TEXT_SECONDARY}Scanning `$NetworkRange.1-254...`${ANSI.RESET}"

`$activeDevices = @()
for (`$i = 1; `$i -le 254; `$i++) {
    `$ip = "`$NetworkRange.`$i"
    Write-Host "`${ANSI.TEXT_SECONDARY}Checking `$ip...`${ANSI.RESET}" -NoNewline
    
    try {
        `$pingResult = Test-Connection -ComputerName `$ip -Count 1 -Quiet -TimeoutSeconds (`$Timeout/1000)
        if (`$pingResult) {
            Write-Host " `$ANSI.GREEN`$(`$pingResult ? 'UP' : 'DOWN')`$ANSI.RESET"
            `$activeDevices += `$ip
        } else {
            Write-Host " `$ANSI.RED`$(`$pingResult ? 'UP' : 'DOWN')`$ANSI.RESET"
        }
    } catch {
        Write-Host " `$ANSI.REDDOWN`$ANSI.RESET"
    }
}

Write-Host ""
Write-Host "`$ANSI.GREEN`$(`$activeDevices.Count) active devices found:`$ANSI.RESET"
`$activeDevices | ForEach-Object { Write-Host " `$ANSI.TEXT_PRIMARY`$_`$ANSI.RESET" }
"@
        }
        
        3 {
            $filePath = Join-Path $outputDir "file_organizer.py"
            $content = @"
#!/usr/bin/env python3
"""
File Organizer
Organizes files by extension into folders
Generated by Knoux Spectre Toolbox
Date: $(Get-Date -Format "yyyy-MM-dd HH:mm")
"""

import os
import shutil
from pathlib import Path

def organize_files(directory):
    """Organize files by extension"""
    print("\\033[38;2;156;163;175m[+] Organizing files in {}\\033[0m".format(directory))
    
    # Common file extensions and their folders
    extensions = {
        'Images': ['.jpg', '.jpeg', '.png', '.gif', '.bmp'],
        'Documents': ['.pdf', '.doc', '.docx', '.txt', '.rtf'],
        'Music': ['.mp3', '.wav', '.flac', '.aac'],
        'Videos': ['.mp4', '.avi', '.mkv', '.mov'],
        'Archives': ['.zip', '.rar', '.7z', '.tar']
    }
    
    # Create folders if they don't exist
    for folder in extensions.keys():
        folder_path = os.path.join(directory, folder)
        if not os.path.exists(folder_path):
            os.makedirs(folder_path)
    
    # Organize files
    for filename in os.listdir(directory):
        file_path = os.path.join(directory, filename)
        
        # Skip directories
        if os.path.isdir(file_path):
            continue
            
        # Get file extension
        _, ext = os.path.splitext(filename)
        ext = ext.lower()
        
        # Move file to appropriate folder
        for folder