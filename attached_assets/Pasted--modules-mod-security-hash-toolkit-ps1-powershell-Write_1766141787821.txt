## üìÑ modules/mod.security/hash.toolkit.ps1 (Áª≠)

```powershell
    Write-Host " ${ANSI.PURPLE}3${ANSI.RESET} ${ANSI.TEXT_PRIMARY}SHA256${ANSI.RESET}"
    Write-Host " ${ANSI.PURPLE}4${ANSI.RESET} ${ANSI.TEXT_PRIMARY}SHA512${ANSI.RESET}"
    Write-Host ""
    
    $algoChoice = Read-ValidatedSubInput -Max 4
    
    $algorithm = switch ($algoChoice) {
        1 { "MD5" }
        2 { "SHA1" }
        3 { "SHA256" }
        4 { "SHA512" }
        default { "SHA256" }
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Comparing $algorithm hashes...${ANSI.RESET}"
    
    try {
        $hash1 = Get-FileHash -Path $file1Path -Algorithm $algorithm
        $hash2 = Get-FileHash -Path $file2Path -Algorithm $algorithm
        
        Write-Host ""
        Write-Host "${ANSI.PURPLE}${ANSI.BOLD}HASH COMPARISON${ANSI.RESET}"
        Write-Host "${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Algorithm:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$algorithm${ANSI.RESET}"
        Write-Host ""
        Write-Host "${ANSI.TEXT_SECONDARY}File 1:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$file1Path${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Hash:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$($hash1.Hash)${ANSI.RESET}"
        Write-Host ""
        Write-Host "${ANSI.TEXT_SECONDARY}File 2:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$file2Path${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Hash:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$($hash2.Hash)${ANSI.RESET}"
        Write-Host ""
        
        if ($hash1.Hash -eq $hash2.Hash) {
            Write-Host "${ANSI.GREEN}‚úì Hashes MATCH - Files are identical${ANSI.RESET}"
        } else {
            Write-Host "${ANSI.RED}√ó Hashes DO NOT MATCH - Files are different${ANSI.RESET}"
        }
    } catch {
        Write-Host "${ANSI.RED}√ó Error comparing hashes: $($_.Exception.Message)${ANSI.RESET}"
    }
}

function Verify-FileIntegrity {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter file path:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $filePath = Read-Host
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter expected hash:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $expectedHash = Read-Host
    
    if ([string]::IsNullOrWhiteSpace($filePath) -or [string]::IsNullOrWhiteSpace($expectedHash)) {
        Write-Host "${ANSI.RED}√ó File path and hash cannot be empty${ANSI.RESET}"
        return
    }
    
    if (-not (Test-Path $filePath)) {
        Write-Host "${ANSI.RED}√ó File not found: $filePath${ANSI.RESET}"
        return
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Select hash algorithm:${ANSI.RESET}"
    Write-Host " ${ANSI.PURPLE}1${ANSI.RESET} ${ANSI.TEXT_PRIMARY}MD5${ANSI.RESET}"
    Write-Host " ${ANSI.PURPLE}2${ANSI.RESET} ${ANSI.TEXT_PRIMARY}SHA1${ANSI.RESET}"
    Write-Host " ${ANSI.PURPLE}3${ANSI.RESET} ${ANSI.TEXT_PRIMARY}SHA256${ANSI.RESET}"
    Write-Host " ${ANSI.PURPLE}4${ANSI.RESET} ${ANSI.TEXT_PRIMARY}SHA512${ANSI.RESET}"
    Write-Host ""
    
    $algoChoice = Read-ValidatedSubInput -Max 4
    
    $algorithm = switch ($algoChoice) {
        1 { "MD5" }
        2 { "SHA1" }
        3 { "SHA256" }
        4 { "SHA512" }
        default { "SHA256" }
    }
    
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Verifying file integrity...${ANSI.RESET}"
    
    try {
        $actualHash = Get-FileHash -Path $filePath -Algorithm $algorithm
        
        Write-Host ""
        Write-Host "${ANSI.PURPLE}${ANSI.BOLD}INTEGRITY CHECK${ANSI.RESET}"
        Write-Host "${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Algorithm:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$algorithm${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}File:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$filePath${ANSI.RESET}"
        Write-Host ""
        Write-Host "${ANSI.TEXT_SECONDARY}Expected Hash:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$expectedHash${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Actual Hash:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$($actualHash.Hash)${ANSI.RESET}"
        Write-Host ""
        
        if ($actualHash.Hash -eq $expectedHash) {
            Write-Host "${ANSI.GREEN}‚úì INTEGRITY VERIFIED - File is authentic${ANSI.RESET}"
        } else {
            Write-Host "${ANSI.RED}√ó INTEGRITY CHECK FAILED - File may be corrupted or tampered${ANSI.RESET}"
        }
    } catch {
        Write-Host "${ANSI.RED}√ó Error verifying integrity: $($_.Exception.Message)${ANSI.RESET}"
    }
}

function Lookup-HashDatabase {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter hash to lookup:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $hash = Read-Host
    
    if ([string]::IsNullOrWhiteSpace($hash)) {
        Write-Host "${ANSI.RED}√ó Hash cannot be empty${ANSI.RESET}"
        return
    }
    
    # Format hash (remove spaces, convert to uppercase)
    $formattedHash = $hash.Replace(" ", "").ToUpper()
    
    # Determine hash type based on length
    $hashType = switch ($formattedHash.Length) {
        32 { "MD5" }
        40 { "SHA1" }
        64 { "SHA256" }
        128 { "SHA512" }
        default { "Unknown" }
    }
    
    Write-Host ""
    Write-Host "${ANSI.PURPLE}${ANSI.BOLD}HASH INFORMATION${ANSI.RESET}"
    Write-Host "${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
    Write-Host "${ANSI.TEXT_SECONDARY}Hash:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$formattedHash${ANSI.RESET}"
    Write-Host "${ANSI.TEXT_SECONDARY}Type:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$hashType${ANSI.RESET}"
    Write-Host ""
    
    # Simulate database lookup (in a real implementation, this would connect to actual databases)
    Write-Host "${ANSI.TEXT_SECONDARY}Searching in threat databases...${ANSI.RESET}"
    Start-Sleep -Milliseconds 1000
    
    # Mock results for demonstration
    $knownMalwareHashes = @(
        "E99A18C428CB38D5F260853678922E03",  # Example MD5 of EICAR test file
        "35D60C480BEACAE4E1A91D1A6A50DB84793107FC",  # Example SHA1
        "275A021BBFB6489E54D471899F7DB9D1663FC695EC2FE2A2C4538AABF9A00BFF"  # Example SHA256
    )
    
    if ($knownMalwareHashes -contains $formattedHash) {
        Write-Host "${ANSI.RED}‚ö† THREAT DETECTED${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}This hash is associated with known malware${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Recommendation: Do not use this file${ANSI.RESET}"
    } else {
        Write-Host "${ANSI.GREEN}‚úì No known threats associated with this hash${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Note: This does not guarantee safety, only no known database matches${ANSI.RESET}"
    }
}

Export-ModuleMember -Function @('Show-HashToolkit')
```

‚úÖ Security & Pentest module created

---
## üìä PROCESS & MEMORY MODULE

üìÑ Creating `modules/mod.process/memory.analyzer.ps1`:

```powershell
<#
.SYNOPSIS
    Knoux Spectre Memory Analyzer
.DESCRIPTION
    Analyze system memory usage and manage processes
.AUTHOR
    Knoux Systems
.VERSION
    1.0.0
#>

function Show-MemoryAnalyzer {
    [CmdletBinding()]
    param()
    
    Clear-ScreenWithBackground
    Write-Host "${ANSI.BG_DARK}${ANSI.PURPLE}${ANSI.BOLD}üìä MEMORY ANALYZER${ANSI.RESET}"
    Write-Host "${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
    Write-Host ""
    
    do {
        Write-Host "${ANSI.TEXT_SECONDARY}Memory Analysis Options:${ANSI.RESET}"
        Write-Host " ${ANSI.PURPLE}1${ANSI.RESET} ${ANSI.TEXT_PRIMARY}System Memory Overview${ANSI.RESET}"
        Write-Host " ${ANSI.PURPLE}2${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Top Memory Consumers${ANSI.RESET}"
        Write-Host " ${ANSI.PURPLE}3${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Process Manager${ANSI.RESET}"
        Write-Host " ${ANSI.PURPLE}4${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Memory Dump Analysis${ANSI.RESET}"
        Write-Host " ${ANSI.PURPLE}5${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Performance Monitor${ANSI.RESET}"
        Write-Host ""
        Write-Host " ${ANSI.RED}0${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Back to Menu${ANSI.RESET}"
        Write-Host ""
        
        $choice = Read-ValidatedSubInput -Max 5
        
        switch ($choice) {
            0 { return }
            1 { Get-SystemMemoryOverview }
            2 { Get-TopMemoryConsumers }
            3 { Show-ProcessManager }
            4 { Analyze-MemoryDump }
            5 { Show-PerformanceMonitor }
        }
        
        Write-Host ""
        Write-Host "${ANSI.TEXT_SECONDARY}Press any key to continue...${ANSI.RESET}"
        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
        Clear-ScreenWithBackground
        
    } while ($true)
}

function Get-SystemMemoryOverview {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Collecting system memory information...${ANSI.RESET}"
    
    try {
        # Get computer system info
        $computerSystem = Get-CimInstance Win32_ComputerSystem
        # Get OS info
        $os = Get-CimInstance Win32_OperatingSystem
        # Get memory info
        $memory = Get-CimInstance Win32_PhysicalMemory
        # Get page file info
        $pageFile = Get-CimInstance Win32_PageFileUsage
        
        # Calculate values
        $totalPhysicalMemory = $computerSystem.TotalPhysicalMemory / 1GB
        $freePhysicalMemory = $os.FreePhysicalMemory * 1KB / 1GB
        $usedPhysicalMemory = $totalPhysicalMemory - $freePhysicalMemory
        $physicalMemoryPercent = [math]::Round(($usedPhysicalMemory / $totalPhysicalMemory) * 100, 2)
        
        $totalVirtualMemory = $os.TotalVirtualMemorySize * 1KB / 1GB
        $freeVirtualMemory = $os.FreeVirtualMemory * 1KB / 1GB
        $usedVirtualMemory = $totalVirtualMemory - $freeVirtualMemory
        $virtualMemoryPercent = [math]::Round(($usedVirtualMemory / $totalVirtualMemory) * 100, 2)
        
        Write-Host ""
        Write-Host "${ANSI.PURPLE}${ANSI.BOLD}SYSTEM MEMORY OVERVIEW${ANSI.RESET}"
        Write-Host "${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
        
        # Physical Memory
        Write-Host ""
        Write-Host "${ANSI.TEXT_SECONDARY}PHYSICAL MEMORY${ANSI.RESET}"
        Write-Host "${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Total:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$([math]::Round($totalPhysicalMemory, 2)) GB${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Used:${ANSI.RESET}  ${ANSI.TEXT_PRIMARY}$([math]::Round($usedPhysicalMemory, 2)) GB ($physicalMemoryPercent%)${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Free:${ANSI.RESET}  ${ANSI.TEXT_PRIMARY}$([math]::Round($freePhysicalMemory, 2)) GB$(
            if ($physicalMemoryPercent -gt 80) { " ${ANSI.RED}(High Usage)${ANSI.RESET}" }
            elseif ($physicalMemoryPercent -gt 60) { " ${ANSI.ORANGE}(Moderate Usage)${ANSI.RESET}" }
            else { " ${ANSI.GREEN}(Normal)${ANSI.RESET}" }
        )"
        
        # Virtual Memory
        Write-Host ""
        Write-Host "${ANSI.TEXT_SECONDARY}VIRTUAL MEMORY${ANSI.RESET}"
        Write-Host "${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Total:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$([math]::Round($totalVirtualMemory, 2)) GB${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Used:${ANSI.RESET}  ${ANSI.TEXT_PRIMARY}$([math]::Round($usedVirtualMemory, 2)) GB ($virtualMemoryPercent%)${ANSI.RESET}"
        Write-Host "${ANSI.TEXT_SECONDARY}Free:${ANSI.RESET}  ${ANSI.TEXT_PRIMARY}$([math]::Round($freeVirtualMemory, 2)) GB$(
            if ($virtualMemoryPercent -gt 80) { " ${ANSI.RED}(High Usage)${ANSI.RESET}" }
            elseif ($virtualMemoryPercent -gt 60) { " ${ANSI.ORANGE}(Moderate Usage)${ANSI.RESET}" }
            else { " ${ANSI.GREEN}(Normal)${ANSI.RESET}" }
        )"
        
        # Page File
        if ($pageFile) {
            Write-Host ""
            Write-Host "${ANSI.TEXT_SECONDARY}PAGE FILE${ANSI.RESET}"
            Write-Host "${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
            Write-Host "${ANSI.TEXT_SECONDARY}Current Usage:${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$([math]::Round($pageFile.CurrentUsage, 2)) MB${ANSI.RESET}"
            Write-Host "${ANSI.TEXT_SECONDARY}Peak Usage:${ANSI.RESET}   ${ANSI.TEXT_PRIMARY}$([math]::Round($pageFile.PeakUsage, 2)) MB${ANSI.RESET}"
        }
        
        # Memory Modules
        Write-Host ""
        Write-Host "${ANSI.TEXT_SECONDARY}MEMORY MODULES${ANSI.RESET}"
        Write-Host "${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
        $memory | ForEach-Object {
            $capacityGB = $_.Capacity / 1GB
            Write-Host " ${ANSI.GREEN}‚óè${ANSI.RESET} ${ANSI.TEXT_PRIMARY}$([math]::Round($capacityGB, 2)) GB${ANSI.RESET} ${ANSI.TEXT_SECONDARY}($($_.Manufacturer) $($_.PartNumber))${ANSI.RESET}"
        }
        
    } catch {
        Write-Host "${ANSI.RED}√ó Error collecting memory information: $($_.Exception.Message)${ANSI.RESET}"
    }
}

function Get-TopMemoryConsumers {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Analyzing top memory consumers...${ANSI.RESET}"
    
    try {
        # Get top 10 processes by memory usage
        $topProcesses = Get-Process | Sort-Object WS -Descending | Select-Object -First 10
        
        Write-Host ""
        Write-Host "${ANSI.PURPLE}${ANSI.BOLD}TOP MEMORY CONSUMERS${ANSI.RESET}"
        Write-Host "${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
        Write-Host " ${ANSI.PURPLE}Rank${ANSI.RESET} ${ANSI.TEXT_SECONDARY}‚îÇ${ANSI.RESET} ${ANSI.PURPLE}Process${ANSI.RESET} ${ANSI.TEXT_SECONDARY}‚îÇ${ANSI.RESET} ${ANSI.PURPLE}Working Set${ANSI.RESET} ${ANSI.TEXT_SECONDARY}‚îÇ${ANSI.RESET} ${ANSI.PURPLE}Private Memory${ANSI.RESET}"
        Write-Host " ${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
        
        for ($i = 0; $i -lt $topProcesses.Count; $i++) {
            $process = $topProcesses[$i]
            $rank = $i + 1
            $ws = Format-KnouxBytes $process.WS
            $pm = Format-KnouxBytes $process.PrivateMemorySize
            
            Write-Host " ${ANSI.TEXT_SECONDARY}$rank${ANSI.RESET}".PadRight(6) -NoNewline
            Write-Host " ${ANSI.TEXT_SECONDARY}‚îÇ${ANSI.RESET} " -NoNewline
            Write-Host "${ANSI.TEXT_PRIMARY}$($process.ProcessName)${ANSI.RESET}".PadRight(15) -NoNewline
            Write-Host " ${ANSI.TEXT_SECONDARY}‚îÇ${ANSI.RESET} " -NoNewline
            Write-Host "${ANSI.TEXT_PRIMARY}$ws${ANSI.RESET}".PadRight(15) -NoNewline
            Write-Host " ${ANSI.TEXT_SECONDARY}‚îÇ${ANSI.RESET} " -NoNewline
            Write-Host "${ANSI.TEXT_PRIMARY}$pm${ANSI.RESET}"
        }
        
        Write-Host ""
        Write-Host "${ANSI.TEXT_SECONDARY}Total memory consumed by top 10: $(Format-KnouxBytes ($topProcesses | Measure-Object WS -Sum).Sum)${ANSI.RESET}"
        
    } catch {
        Write-Host "${ANSI.RED}√ó Error analyzing memory consumers: $($_.Exception.Message)${ANSI.RESET}"
    }
}

function Show-ProcessManager {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Process Manager Options:${ANSI.RESET}"
    Write-Host " ${ANSI.PURPLE}1${ANSI.RESET} ${ANSI.TEXT_PRIMARY}List All Processes${ANSI.RESET}"
    Write-Host " ${ANSI.PURPLE}2${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Kill Process by Name${ANSI.RESET}"
    Write-Host " ${ANSI.PURPLE}3${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Kill Process by PID${ANSI.RESET}"
    Write-Host " ${ANSI.PURPLE}4${ANSI.RESET} ${ANSI.TEXT_PRIMARY}Search Processes${ANSI.RESET}"
    Write-Host ""
    
    $choice = Read-ValidatedSubInput -Max 4
    
    switch ($choice) {
        1 { List-AllProcesses }
        2 { Kill-ProcessByName }
        3 { Kill-ProcessById }
        4 { Search-Processes }
    }
}

function List-AllProcesses {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Listing all processes...${ANSI.RESET}"
    
    try {
        $processes = Get-Process | Sort-Object ProcessName
        
        Write-Host ""
        Write-Host "${ANSI.PURPLE}${ANSI.BOLD}ALL PROCESSES ($($processes.Count))${ANSI.RESET}"
        Write-Host "${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
        Write-Host " ${ANSI.PURPLE}PID${ANSI.RESET}  ${ANSI.TEXT_SECONDARY}‚îÇ${ANSI.RESET} ${ANSI.PURPLE}Name${ANSI.RESET} ${ANSI.TEXT_SECONDARY}‚îÇ${ANSI.RESET} ${ANSI.PURPLE}Memory${ANSI.RESET} ${ANSI.TEXT_SECONDARY}‚îÇ${ANSI.RESET} ${ANSI.PURPLE}CPU${ANSI.RESET}"
        Write-Host " ${ANSI.BORDER}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${ANSI.RESET}"
        
        $processes | Select-Object -First 30 | ForEach-Object {
            $pid = $_.Id
            $name = $_.ProcessName
            $memory = Format-KnouxBytes $_.WS
            $cpu = if ($_.CPU -ne $null) { "$([math]::Round($_.CPU, 2)) s" } else { "N/A" }
            
            Write-Host " ${ANSI.TEXT_SECONDARY}$pid${ANSI.RESET}".PadRight(7) -NoNewline
            Write-Host " ${ANSI.TEXT_SECONDARY}‚îÇ${ANSI.RESET} " -NoNewline
            Write-Host "${ANSI.TEXT_PRIMARY}$name${ANSI.RESET}".PadRight(15) -NoNewline
            Write-Host " ${ANSI.TEXT_SECONDARY}‚îÇ${ANSI.RESET} " -NoNewline
            Write-Host "${ANSI.TEXT_PRIMARY}$memory${ANSI.RESET}".PadRight(12) -NoNewline
            Write-Host " ${ANSI.TEXT_SECONDARY}‚îÇ${ANSI.RESET} " -NoNewline
            Write-Host "${ANSI.TEXT_PRIMARY}$cpu${ANSI.RESET}"
        }
        
        if ($processes.Count -gt 30) {
            Write-Host ""
            Write-Host "${ANSI.TEXT_SECONDARY}Showing first 30 of $($processes.Count) processes${ANSI.RESET}"
        }
        
    } catch {
        Write-Host "${ANSI.RED}√ó Error listing processes: $($_.Exception.Message)${ANSI.RESET}"
    }
}

function Kill-ProcessByName {
    Write-Host ""
    Write-Host "${ANSI.TEXT_SECONDARY}Enter process name to kill:${ANSI.RESET}"
    Write-Host "${ANSI.PURPLE}>>${ANSI.RESET} " -NoNewline
    $processName = Read-Host
    
    if ([string]::IsNullOrWhiteSpace($processName)) {
        Write-Host "${ANSI.RED}√ó Process name cannot be empty${ANSI.RESET}"
        return
    }
    
    try {
        $processes = Get-Process -Name $processName -ErrorAction Stop
        
        if ($processes.Count -eq 0) {
            Write-Host "${ANSI.TEXT_SECONDARY}No processes found with name '$processName'${ANSI.RESET}"
            return
        }
        
        Write-Host ""
        Write-Host "${ANSI.ORANGE}? Found $($processes.Count) process(es) with name '$processName'${ANSI.RESET}"
        
        $processes | ForEach-Object {
            Write-Host " ${ANSI.RED}‚óè${ANSI.RESET} ${ANSI.TEXT_PRIMARY}PID: $($_.Id)${ANSI.RESET} ${ANSI.TEXT_SECONDARY}| Memory: $(Format-KnouxBytes $_.WS)${ANSI.RESET}"
        }
        
        $confirm = Confirm-KnouxAction "Kill all processes named '$processName'?" "N"
        
        if ($confirm) {
            if (-not (Test-AdminPrivilege)) {
                Write-Host ""
                Write-Host "${ANSI.ORANGE}‚ö† Administrator privileges may be required to kill some processes${ANSI.RESET}"
            }
            
            $killed = 0
            $failed = 0
            
            foreach ($process in $processes) {
                try {
                    Write-Host "${ANSI.TEXT_SECONDARY}Killing PID $($process.Id)...${ANSI.RESET}" -NoNewline
                    $process | Stop-Process -Force -ErrorAction Stop
                    Write-Host " ${ANSI.GREEN}DONE${ANSI.RESET}"
                    $killed++
                } catch {
                    Write-Host " ${ANSI.RED}FAILED${ANSI.RESET}"
                    $failed++
                }
            }
            
            Write-Host ""
            Write-Host "${ANSI.GREEN}‚úì Killed $killed process(es)${ANSI.RESET}"
            if ($failed -gt 0) {
                Write-Host "${ANSI.RED}√ó Failed to kill $failed process(es)${ANSI.RESET}"
            }
        } else
```